<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>zoomout_quiz_display</title>
  <style>
    canvas {
      border: 1px solid #000;
      display: block;
      margin: 10px auto;
      cursor: crosshair;
    }
    #controls {
      text-align: center;
      margin: 10px;
    }
    button, .file-label {
      height: 30px;
      padding: 0 12px;
      font-size: 14px;
      margin: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      display: inline-block;
      text-align: center;
      line-height: 30px;
      vertical-align: middle;
      box-sizing: border-box;
      font-family: Arial, Helvetica, sans-serif;
    }
    .file-input-hidden {
      display: none;
    }
    input[type="number"] {
      height: 30px;
      font-size: 14px;
      margin: 5px;
      padding: 0 10px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="imageLoader" class="file-label">Choose Picture</label>
    <input type="file" id="imageLoader" accept="image/*" multiple class="file-input-hidden">
    <button id="addQueueBtn">Queue</button>
    <button id="startBtn">Start</button>
    <button id="toggleBtn">Pause</button>
    <button id="nextBtn">Next</button>
    <label for="speedInput">Speed (seconds):</label>
    <input type="number" id="speedInput" min="1" max="100" step="1" value="30">
    <button id="saveQueueBtn">Save Queue</button>
    <label for="loadQueueInput" class="file-label">Load Queue</label>
    <input type="file" id="loadQueueInput" accept=".json,.txt" class="file-input-hidden">
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageLoader = document.getElementById('imageLoader');
    const toggleBtn = document.getElementById('toggleBtn');
    const startBtn = document.getElementById('startBtn');
    const speedInput = document.getElementById('speedInput');
    const addQueueBtn = document.getElementById('addQueueBtn');
    const nextBtn = document.getElementById('nextBtn');
    const saveQueueBtn = document.getElementById('saveQueueBtn');
    const loadQueueBtn = document.getElementById('loadQueueInput');

    let img = new Image();
    let imgLoaded = false;
    let aspectRatio = 1;

    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let dragW = 0, dragH = 0;

    let revealAnim = null;
    let animationId = null;
    let paused = false;
    let animationDuration = parseInt(speedInput.value, 10) * 1000;

    let queue = [];
    let currentIndex = -1;

    imageLoader.onchange = (e) => {
      const files = Array.from(e.target.files);
      if (!files.length) return;

      loadImage(files[0]);
      imageLoader.filesList = files;
    };

    function loadImage(file, callback) {
      const reader = new FileReader();
      reader.onload = (event) => {
        img = new Image();
        img.onload = () => {
          imgLoaded = true;
          const maxW = 1280;
          const maxH = 720;
          const scale = Math.min(maxW / img.width, maxH / img.height, 1);
          const cw = Math.round(img.width * scale);
          const ch = Math.round(img.height * scale);
          canvas.width = cw;
          canvas.height = ch;
          aspectRatio = canvas.width / canvas.height;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          if (callback) callback();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }

    canvas.onmousedown = (e) => {
      if (!imgLoaded) return;
      const rect = canvas.getBoundingClientRect();
      dragStartX = e.clientX - rect.left;
      dragStartY = e.clientY - rect.top;
      isDragging = true;
    };

    canvas.onmousemove = (e) => {
      if (isDragging && imgLoaded) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const dx = mx - dragStartX;
        const dy = dx / aspectRatio;

        dragW = dx;
        dragH = dy;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.strokeRect(dragStartX, dragStartY, dragW, dragH);
      }
    };

    canvas.onmouseup = () => {
      isDragging = false;
    };

    addQueueBtn.onclick = () => {
      if (!imgLoaded || dragW === 0 || dragH === 0) return;

      queue.push({
        imgSrc: img.src,
        dragStartX,
        dragStartY,
        dragW,
        dragH,
        canvasWidth: canvas.width,
        canvasHeight: canvas.height
      });

      alert('Added to queue: ' + queue.length + ' items');
    };

    nextBtn.onclick = () => {
      if (queue.length === 0) return;
      currentIndex++;
      if (currentIndex >= queue.length) currentIndex = 0;
      showQueueItem(currentIndex);
    };

    function showQueueItem(idx) {
      const item = queue[idx];
      if (!item) return;

      img = new Image();
      img.onload = () => {
        imgLoaded = true;

        canvas.width = item.canvasWidth;
        canvas.height = item.canvasHeight;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.drawImage(
          img,
          item.dragStartX, item.dragStartY, 0, 0,
          0, 0, canvas.width, canvas.height
        );
      };

      img.src = item.imgSrc;
    }

    speedInput.oninput = function() {
      const value = parseInt(this.value, 10);
      if (value >= 1 && value <= 100) {
        animationDuration = value * 1000;
      } else {
        alert('Please enter a value between 1 and 100 seconds.');
      }
    };

    startBtn.onclick = () => {
      if (!imgLoaded || dragW === 0 || dragH === 0) return;

      const left0 = dragStartX;
      const top0 = dragStartY;
      const right0 = dragStartX + dragW;
      const bottom0 = dragStartY + dragH;

      const left1 = 0;
      const top1 = 0;
      const right1 = canvas.width;
      const bottom1 = canvas.height;

      revealAnim = {
        left0, top0, right0, bottom0,
        left1, top1, right1, bottom1
      };

      animationStart = null;
      paused = false;
      toggleBtn.textContent = 'Pause';
      cancelAnimationFrame(animationId);
      requestAnimationFrame(drawAnim);
    };

    toggleBtn.onclick = () => {
      if (!revealAnim) return;
      paused = !paused;
      toggleBtn.textContent = paused ? 'Restart' : 'Pause';
      if (!paused) requestAnimationFrame(drawAnim);
    };

    function drawAnim(ts) {
      if (paused) return;
      if (!animationStart) animationStart = ts;
      let progress = (ts - animationStart) / animationDuration;
      if (progress > 1) progress = 1;

      function easeInOutCubic(x) {
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
      }
      progress = easeInOutCubic(progress);

      const {
        left0, top0, right0, bottom0,
        left1, top1, right1, bottom1
      } = revealAnim;

      const w0 = right0 - left0;
      const h0 = bottom0 - top0;
      const w1 = right1 - left1;
      const h1 = bottom1 - top1;

      const w = w0 + (w1 - w0) * progress;
      const h = h0 + (h1 - h0) * progress;

      const cx0 = left0 + w0 / 2;
      const cy0 = top0 + h0 / 2;
      const cx1 = left1 + w1 / 2;
      const cy1 = top1 + h1 / 2;
      const cx = cx0 + (cx1 - cx0) * progress;
      const cy = cy0 + (cy1 - cy0) * progress;

      const left = cx - w / 2;
      const top = cy - h / 2;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(
        img,
        left, top, w, h,
        0, 0, canvas.width, canvas.height
      );

      if (progress < 1) {
        animationId = requestAnimationFrame(drawAnim);
      } else {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      }
    }

    saveQueueBtn.onclick = () => {
      if (!queue.length) {
        alert('Queue is currently empty.');
        return;
      }
      const dataStr = JSON.stringify(queue);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'queue_state.json';
      a.click();
      URL.revokeObjectURL(url);
    };

    loadQueueBtn.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (evt) => {
        try {
          const loadedQueue = JSON.parse(evt.target.result);
          if (Array.isArray(loadedQueue)) {
            queue = loadedQueue;
            currentIndex = queue.length > 0 ? 0 : -1;

            if (currentIndex >= 0) {
              showQueueItem(currentIndex);
            }

            alert('Queue loaded successfully. Length: ' + queue.length);
          } else {
            alert('Invalid queue file.');
          }
        } catch (err) {
          alert('Error processing file: ' + err.message);
        }
      };
      reader.readAsText(file);
    };
  </script>
</body>
</html>